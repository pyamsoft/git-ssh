#!/bin/sh
#  Copyright (C) 2016 Peter Kenji Yamanaka
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# A bash script that wraps git calls to work with a specific SSH key

# git-ssh
# An ssh-key selection wrapper for git

# NOTE: This script does not check that the SSH key is valid, and does not
# sanitize input. Please make sure all input passed into the script is
# valid either in the context of the script or the git binary itself

# Export the LC as the default C so that we do not run into locale based quirks
export LC_ALL=C

# git-ssh
version="0.5.2"

# config file version
config_version="2"

# Location of the actual git binary
_git="/usr/bin/git"
git_args=""

# Location of the dir with configs stored
config_dir="$XDG_CONFIG_HOME/git-ssh"

# The ssh key requested
ssh_key=""
ssh_args=""

# The ssh key git should use
git_ssh_path=""

# No argument options
should_list_configs=0
wrapper_debug=0

# Parameters for creating a new configuration
create_config_name=""
create_config_path=""

# Parameters for removing a config
remove_config_name=""

# Is this call to git going to be handled by the wrapper
handled_by_wrapper=0
handled_by_create=0
handled_by_remove=0

# These are set when the next passed in argument is expected
# to be a valid parameter
expect_ssh_key=0
expect_config_dir=0
expect_create_config_name=0
expect_create_config_path=0
expect_remove_config_name=0
expect_ssh_args=0

log()
{
  if [ "${wrapper_debug}" -ne 0 ]; then
    printf -- "%s\n" "$1"
  fi
}

# Check the environment path for the given binary, exit if it is not found
check_for_binary()
{
  if ! which "$1" > /dev/null 2>&1; then
    printf -- "The '%s' binary is required for this script.\n" "$1"
    printf -- "Please install '%s' onto your system.\n" "$1"
    exit 1
  fi
}

# Sets the ssh_key
handle_ssh_key_option()
{
  log "ssh_key set to '$1'"
  expect_ssh_key=0
  ssh_key="$1"
}

# Sets the config_dir
handle_config_dir_option()
{
  log "config_dir set to '$1'"
  expect_config_dir=0
  config_dir="$1"
}

handle_create_config_name()
{
  log "create_config_name set to '$1'"
  expect_create_config_name=0
  expect_create_config_path=1
  create_config_name="$1"
}

handle_create_config_path()
{
  log "create_config_path set to '$1'"
  expect_create_config_path=0
  create_config_path="$1"
}

handle_remove_config_name()
{
  log "remove_config_name set to '$1'"
  expect_remove_config_name=0
  remove_config_name="$1"
}

handle_ssh_args_option()
{
  expect_ssh_args=0
  check_for_binary tr
  local split_ssh_args="$(printf -- "$1" | tr "," "\n")"
  for arg in ${split_ssh_args}; do
    if [ -z "${ssh_args}" ]; then
      ssh_args="${arg}"
    else
      ssh_args="${ssh_args} ${arg}"
    fi
  done
  log "ssh_args set to '${ssh_args}'"
}

prepare_ssh_key_option()
{
  # Handle this call to git with the wrapper
  if [ "${handled_by_wrapper}" -ne 1 ]; then
    log "This git call is handled by wrapper"
    handled_by_wrapper=1
  fi

  if [ "${expect_ssh_key}" -ne 1 ]; then
    log "Expect ssh_key next"
    expect_ssh_key=1
  fi
}

prepare_config_dir_option()
{
  # Handle this call to git with the wrapper
  if [ "${handled_by_wrapper}" -ne 1 ]; then
    log "This git call is handled by wrapper"
    handled_by_wrapper=1
  fi

  if [ "${expect_config_dir}" -ne 1 ]; then
    log "Expect config_dir next"
    expect_config_dir=1
  fi
}

prepare_ssh_args()
{
  # Handle this call to git with the wrapper
  if [ "${handled_by_wrapper}" -ne 1 ]; then
    log "This git call is handled by wrapper"
    handled_by_wrapper=1
  fi

  if [ "${expect_ssh_args}" -ne 1 ]; then
    log "Expect ssh_args next"
    expect_ssh_args=1
  fi
}

create_config_if_wanted()
{
  if [ "${handled_by_create}" -ne 0 ]; then
    if [ ! -z "${create_config_name}" ] && [ ! -z "${create_config_path}" ]; then
      check_config_dir_conditions || return 1
      printf -- "Create new config: ${create_config_name}\n"

      local config_file="${config_dir}/${create_config_name}.${config_version}"

      # Create the file
      touch "${config_file}"

      # Clear the config
      printf -- "" > "${config_file}"

      # Capture all hosts by default
      printf -- "Host *\n" >> "${config_file}"

      # Set the requested identify file found at ${create_config_path}
      printf -- "    IdentityFile ${create_config_path}\n" >> "${config_file}"

      # Only use identities specified in the config file
      printf -- "    IdentitiesOnly yes\n" >> "${config_file}"

      unset config_file
      echo
    else
      printf -- "ERROR: Cannot create new config.\n"
      printf -- "    name: ${create_config_name}\n"
      printf -- "    path: ${create_config_path}\n"
      return 2
    fi
  fi
}

remove_config_if_wanted()
{
  if [ "${handled_by_remove}" -ne 0 ]; then
    if [ ! -z "${remove_config_name}" ]; then
      check_config_dir_conditions || return 1
      check_for_binary rm
      local target="${config_dir}/${remove_config_name}.${config_version}"
      if [ -e "${target}" ]; then
        rm -f "${target}"
        printf -- "Remove config: ${target}\n"
        echo
      else
        printf -- "Config does not exist: ${target}\n"
        echo
      fi
      unset target
    else
      printf -- "ERROR: No config specified.\n"
      return 2
    fi
  fi
}

list_configs()
{
  check_config_dir_conditions || return 1
  check_for_binary ls
  check_for_binary wc
  check_for_binary head
  local count=$(ls -1 "${config_dir}" | wc -l)
  printf -- "Config directory: ${config_dir}\n"
  printf -- "Number of configs: ${count}\n"
  echo
  for config in "${config_dir}"/*; do
    printf -- "[$(basename "${config}")]\n"
    printf -- "Path: $(cat "${config}" )\n"
    echo
  done
  unset count
}

check_config_dir_conditions()
{
  # No config dir specified
  log "Check for set config dir..."
  if [ -z "${config_dir}" ]; then
    printf -- "ERROR: No config_dir specified\n"
    return 1
  fi

  # Check for the existance of the config file
  log "Check that config dir exists as a directory..."
  if [ ! -d ${config_dir} ]; then
    printf -- "ERROR: config_dir does not exist at:  ${config_dir}\n"
    return 2
  fi
}

check_ssh_key_conditions()
{
  # No ssh key was requested
  log "Check that an ssh_key was requested..."
  if [ -z "${ssh_key}" ]; then
    printf -- "ERROR: No ssh_key was requested\n"
    return 1
  fi
}

check_wrapper_conditions()
{
  log "Check that wrapper can continue..."
  check_config_dir_conditions || return 1
  check_ssh_key_conditions || return 2
}

autoupdate_old_config()
{
  local base="$(basename "$1" )"

  # Upgrading from git-ssh config version 1
  log "Old config file found at: ${base}"
  log "Auto upgrade to new format"
  log ""

  # Run the methods using info
  prepare_create_config_option
  handle_create_config_name "${ssh_key}"
  handle_create_config_path "$(cat "$1" )"

  local config_auto_result=
  config_auto_result=$(create_config_if_wanted)
  if [ $? -ne 0 ]; then
    log "Failed to auto generate config for version: ${config_version}"
  else
    log "Auto generate config for version: ${config_version}"
    log "Remove old config"
    rm "$1"
  fi
  unset config_auto_result

  # KLUDGE Duplication of code
  # We need this check in here too because our original loop does not
  # account for the fact that a new config was just added
  local new_config="$1.${config_version}"
  base="$(basename "${new_config}" )"
  log "Check for match at (new_config): ${base} and (key): ${ssh_key}.${config_version}"
  if [ "${base}" = "${ssh_key}.${config_version}" ]; then
    git_ssh_path="${new_config}"
    log "Set git_ssh_path to: ${git_ssh_path}"
    unset new_config
    break
  fi

  unset base
  unset new_config
}

locate_config_file()
{
  # Path expanstion via shell
  log "Find configs in ${config_dir}"
  for config in "${config_dir}"/*; do

    # Make sure we've found a config file, not folder
    log "Check that ${config} is a file, not folder"
    if [ ! -d "${config}" ]; then
      # Read the config if it is the one we want
      local base="$(basename "${config}" )"
      log "Check for match at (config): ${base} and (key): ${ssh_key}.${config_version}"
      if [ "${base}" = "${ssh_key}" ]; then
        autoupdate_old_config "${config}"
      elif [ "${base}" = "${ssh_key}.${config_version}" ]; then
        git_ssh_path="${config}"
        log "Set git_ssh_path to: ${git_ssh_path}"
        break
      fi
      unset base
    fi
  done
}

check_valid_ssh_path()
{
  # If no matching key was found
  log "Check for git_ssh_path: ${git_ssh_path}"
  if [ -z "${git_ssh_path}" ]; then
    printf -- "ERROR: No key found which matches the requested key: ${ssh_key}\n"
    return 1
  fi
}

prepare_create_config_option()
{
  if [ "${handled_by_create}" -ne 1 ]; then
    log "This git call is handled by create"
    handled_by_create=1
  fi

  if [ "${expect_create_config_name}" -ne 1 ]; then
    log "Expect create_config_name next..."
    expect_create_config_name=1
  fi
}

prepare_remove_config_name()
{
  if [ "${handled_by_remove}" -ne 1 ]; then
    log "This git call is handled by remove"
    handled_by_remove=1
  fi

  if [ "${expect_remove_config_name}" -ne 1 ]; then
    log "Expect remove_config_name next..."
    expect_remove_config_name=1
  fi
}

print_version()
{
  printf -- "git-ssh [${version}]\n"
  echo
}

list_wrapper_help()
{
  print_version
  printf -- "options\n"
  echo
  printf -- "  --ssh CONFIG               The name identifier of a config file in the \${config_dir}.\n"
  printf -- "  --ssh-args COMMA-OPTIONS   Comma separated list of options to pass to ssh.\n"
  printf -- "  --config-dir DIR           The path to the directory where configs are stored.\n"
  printf -- "  --create-config NAME PATH  Create a config called NAME with\n"
  printf -- "                             the path PATH. Does not stop operation following completion.\n"
  printf -- "  --remove-config NAME       Remove the config specified by NAME.\n"
  printf -- "                             Does not stop operation following completion.\n"
  printf -- "  --list-configs             Lists the contents of the \${config_dir}.\n"
  printf -- "                             Stops operation following completion.\n"
  printf -- "  --wrapper-version          Prints the current wrapper version\n"
  printf -- "  --wrapper-help             Prints only this help block\n"
  printf -- "  --wrapper-debug            Enables debugging statements\n"
  printf -- "  --help                     Prints this help block followed by git --help\n"
  echo
}

# Options to passthrough to git
# KLUDGE not currently implemented
#        See below in the switch statement
#
# git_options=""

# We need git, cat, env, and ssh
# In the case of git, we check that the path resolves
check_for_binary "${_git}"
check_for_binary cat
check_for_binary ssh
check_for_binary env

# We have everything, let's go
if [ -z "$1" ]; then
  # Just run git
  exec "${_git}" "$@"
fi

# Super hacky option parsing
# Loop through the options passed in var $@
# If the option is a valid case in the switch statement
# it will set an expected_$$ flag
#
# If the flag is set, the next variable passed in is expected to be
# a valid parameter for the given option.
# The option call --${opt} and its argument ${arg} are shifted out of the
# array $@ so that only the options passed to git are left
for option in "$@"; do

  # Check for any expected options
  if [ "${expect_ssh_key}" -ne 0 ]; then
    handle_ssh_key_option "${option}"
    shift
    continue
  elif [ "${expect_config_dir}" -ne 0 ]; then
    handle_config_dir_option "${option}"
    shift
    continue
  elif [ "${expect_create_config_name}" -ne 0 ]; then
    handle_create_config_name "${option}"
    shift
    continue
  elif [ "${expect_create_config_path}" -ne 0 ]; then
    handle_create_config_path "${option}"
    shift
    continue
  elif [ "${expect_remove_config_name}" -ne 0 ]; then
    handle_remove_config_name "${option}"
    shift
    continue
  elif [ "${expect_ssh_args}" -ne 0 ]; then
    handle_ssh_args_option "${option}"
    shift
    continue
  fi

  case "${option}" in
    "--ssh")
      prepare_ssh_key_option
      shift
      ;;
    "--config-dir")
      prepare_config_dir_option
      shift
      ;;
    "--create-config")
      prepare_create_config_option
      shift
      ;;
    "--remove-config")
      prepare_remove_config_name
      shift
      ;;
    "--ssh-args")
      prepare_ssh_args
      shift
      ;;
    "--list-configs")
      should_list_configs=1
      shift
      ;;
    "--wrapper-debug")
      wrapper_debug=1
      log "Turn on wrapper debugging"
      shift
      ;;
    "--wrapper-help")
      list_wrapper_help
      # The help call ends the script
      exit 0
      ;;
    "--help")
      list_wrapper_help
      eval "exec ${_git} ${git_args} --help"
      ;;
    "--wrapper-version")
      print_version
      # The version call ends the script
      exit 0
      ;;
    *)
      log "Sanitize raw git argument: \"$1\""
      if [ -z "${git_args}" ]; then
        git_args="'${1}'"
      else
        git_args="${git_args} '${1}'"
      fi
      # git_options="$1 ${git_options}"
      shift

      # KLUDGE Limiations
      # Do nothing
      ;;
  esac
done

# Remove the config if requested
remove_config_if_wanted || exit 1

# Create the config if requested
create_config_if_wanted || exit 1

if [ "${should_list_configs}" -ne 0 ]; then
  list_configs || exit 1
  exit 1
fi


# Wrapper does not play a part
if [ "${handled_by_wrapper}" -eq 0 ]; then
  # Just run git
  # We use eval to convert the raw strings into arguments for git
  # This is not the safest solution but currently appears to work
  log "Call does not request wrapper options, call git normally"
  eval "exec ${_git} ${git_args}"
fi

# Make sure everything is set
check_wrapper_conditions || exit 2

# Read the config file requested and check its valid
locate_config_file
check_valid_ssh_path || exit 3

# Run git using the ssh key that was found
# Git will handle any errors related to a bad path
# to an SSH key, just as if you had entered this env var yourself

# We use eval to convert the raw strings into arguments for git
# This is not the safest solution but currently appears to work
#
# Escape the double quotes so that the shell does not attempt to parse the
# options given to GIT_SSH_COMMAND
#
# Escape the GIT_SSH_COMMAND with double quotes to allow paths with spaces
# and single quotes to be passed through
log "Call requests wrapper options, call wrapper git"
log "GIT_SSH_COMMAND='ssh -F \"${git_ssh_path}\" ${ssh_args}'"
log "GIT: ${_git}"
log "ARGS: ${git_args}"
eval "exec env GIT_SSH_COMMAND='ssh -F \"${git_ssh_path}\" ${ssh_args}' ${_git} ${git_args}"

# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:
