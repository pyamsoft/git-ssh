#!/bin/sh
#  Copyright (C) 2016 Peter Kenji Yamanaka
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# A bash script that wraps git calls to work with a specific SSH key

# git-ssh
# An ssh-key selection wrapper for git

# NOTE: This script does not check that the SSH key is valid, and does not
# sanitize input. Please make sure all input passed into the script is
# valid either in the context of the script or the git binary itself

# Export the LC as the default C so that we do not run into locale based quirks
export LC_ALL=C

# git-ssh
readonly VERSION="0.6.0"

# config file version
readonly CONFIG_VERSION="2"

# Location of the actual git binary
readonly GIT_BINARY="/usr/bin/git"
git_args=""

# Location of the dir with configs stored
config_dir="$XDG_CONFIG_HOME/git-ssh"

# The ssh key requested
ssh_key=""
__ssh_args=""

# The ssh key git should use
__git_ssh_path=""

# No argument options
wrapper_debug=0

# Parameters for creating a config
__create_config_name=""
__create_config_target=""

# Parameters for removing a config
remove_config_name=""

# Is this call to git going to be handled by the wrapper
handled_by_wrapper=0
handled_by_create=0
handled_by_remove=0

log()
{
  if [ "${wrapper_debug}" -ne 0 ]; then
    printf -- "%s\n" "$1"
  fi
}

##
# Check the environment path for the given binary, return if it is not found
#
# $1 the binary to check on the PATH
##
check_for_binary()
{
  check_for_binary__bin="$1"
  check_for_binary__old_ifs="${IFS}"
  if [ -z "${check_for_binary__bin}" ]; then
    printf -- "Must specify a path to a binary"
    return 1
  fi

  IFS=":"
  for check_for_binary__path in ${PATH}; do
    check_for_binary__result=
    check_for_binary__result="${check_for_binary__path}/${check_for_binary__bin}"
    if [ -e "${check_for_binary__result}" ]; then
      IFS="${check_for_binary__old_ifs}"

      unset check_for_binary__result
      unset check_for_binary__bin
      unset check_for_binary__old_ifs
      unset check_for_binary__path
      return 0
    fi

    unset check_for_binary__result
  done

  printf -- "Binary '${check_for_binary__bin}' not found in \$PATH"

  unset check_for_binary__result
  unset check_for_binary__bin
  unset check_for_binary__old_ifs
  unset check_for_binary__path
  return 1
}

##
# Handle the parsing of command line SSH arguments
#
# $1 ssh arguments, comma separated
handle_ssh_args_option()
{
  ssh_args_comma_separated="$1"
  split_ssh_args=

  check_for_binary tr || return 1
  split_ssh_args="$(printf -- "${ssh_args_comma_separated}" | tr "," "\n")"
  for arg in ${split_ssh_args}; do
    if [ -z "${__ssh_args}" ]; then
      __ssh_args="${arg}"
    else
      __ssh_args="${__ssh_args} ${arg}"
    fi
    unset arg
  done
  log "ssh_args set to '${__ssh_args}'"

  unset ssh_args_comma_separated
  unset split_ssh_args
  return 0
}

handle_create_config()
{
  handle_create_config__args="$1"
  handle_create_config__split=""

  check_for_binary tr || return 1
  handle_create_config__split="$(printf -- "${handle_create_config__args}" | tr ":" "\n")"
  handle_create_config__i=0
  # shellcheck disable=SC2154
  for arg in ${handle_create_config__split}; do
    if [ ${handle_create_config__i} -ge 2 ]; then
      printf -- "Too many config arguments.\n"
      return 1
    elif [ ${handle_create_config__i} -eq 0 ]; then
      __create_config_name="${arg}"
      log "Set Config name: ${__create_config_name}"
    elif [ ${handle_create_config__i} -eq 1 ]; then
      __create_config_target="${arg}"
      log "Set Config target: ${__create_config_target}"
    fi
    handle_create_config__i=$((handle_create_config__i + 1))
  done

  if [ -z "${__create_config_name}" ] || [ -z "${__create_config_target}" ]; then
    printf -- "Either config name or target is not specified\n"
    return 1
  fi

  log "Config name: ${__create_config_name}, target: ${__create_config_target}"

  unset handle_create_config__i
  unset handle_create_config__args
  unset split_config_args
  return 0
}

create_config_if_wanted()
{
  if [ "${handled_by_create}" -ne 0 ]; then
    log "Create requested at ${__create_config_name}, ${__create_config_target}"
    if [ ! -z "${__create_config_name}" ] && [ ! -z "${__create_config_target}" ]; then
      check_config_dir_conditions || return 1
      printf -- "Create new config: ${__create_config_name}\n"

      create_config_if_wanted__file="${config_dir}/${__create_config_name}.${CONFIG_VERSION}"

      # Create the file
      touch "${create_config_if_wanted__file}"

      # Clear the config
      printf -- "" > "${create_config_if_wanted__file}"

      # Capture all hosts by default
      printf -- "Host *\n" >> "${create_config_if_wanted__file}"

      # Set the requested identify file found at ${create_config_path}
      printf -- "    IdentityFile ${__create_config_target}\n" \
        >> "${create_config_if_wanted__file}"

      # Only use identities specified in the config file
      printf -- "    IdentitiesOnly yes\n" >> "${create_config_if_wanted__file}"

      unset create_config_if_wanted__file
    else
      printf -- "ERROR: Cannot create new config.\n"
      printf -- "    name: ${__create_config_name}\n"
      printf -- "    target: ${__create_config_target}\n"
      return 1
    fi
  fi
}

remove_config_if_wanted()
{
  if [ "${handled_by_remove}" -ne 0 ]; then
    if [ ! -z "${remove_config_name}" ]; then
      check_config_dir_conditions || return 1
      check_for_binary rm
      local target="${config_dir}/${remove_config_name}.${CONFIG_VERSION}"
      if [ -e "${target}" ]; then
        rm -f "${target}"
        printf -- "Remove config: ${target}\n"
        echo
      else
        printf -- "Config does not exist: ${target}\n"
        echo
      fi
      unset target
    else
      printf -- "ERROR: No config specified.\n"
      return 2
    fi
  fi
}

##
# List all existing git-ssh configurations
#
# $1 configuration directory
list_configs()
{
  list_configs__config_dir="$1"
  check_config_dir_conditions || return 1
  check_for_binary ls || return 1
  check_for_binary wc || return 1
  check_for_binary head || return 1

  list_configs__count=
  list_configs__count=$(ls -1 "${list_configs__config_dir}" | wc -l)
  printf -- "Config directory: ${list_configs__config_dir}\n"
  printf -- "Number of configs: ${list_configs__count}\n"

  echo
  for list_configs__file in "${list_configs__config_dir}"/*; do
    printf -- "[$(basename "${list_configs__file}")]\n"
    printf -- "Path: $(cat "${list_configs__file}" )\n"
    echo
  done

  unset list_configs__config_dir
  unset list_configs__count
  return 0
}

check_config_dir_conditions()
{
  # No config dir specified
  log "Check for set config dir..."
  if [ -z "${config_dir}" ]; then
    printf -- "ERROR: No config_dir specified\n"
    return 1
  fi

  # Check for the existance of the config file
  log "Check that config dir exists as a directory..."
  if [ ! -d ${config_dir} ]; then
    printf -- "ERROR: config_dir does not exist at:  ${config_dir}\n"
    return 2
  fi
}

check_ssh_key_conditions()
{
  # No ssh key was requested
  log "Check that an ssh_key was requested..."
  if [ -z "${ssh_key}" ]; then
    printf -- "ERROR: No ssh_key was requested\n"
    return 1
  fi
}

check_wrapper_conditions()
{
  log "Check that wrapper can continue..."
  check_config_dir_conditions || return 1
  check_ssh_key_conditions || return 2
}

autoupdate_old_config()
{
  local base="$(basename "$1" )"

  # Upgrading from git-ssh config version 1
  log "Old config file found at: ${base}"
  log "Auto upgrade to new format"
  log ""

  # Run the methods using info
  prepare_create_config_option
  handle_create_config_name "${ssh_key}"
  handle_create_config_path "$(cat "$1" )"

  local config_auto_result=
  config_auto_result=$(create_config_if_wanted)
  if [ $? -ne 0 ]; then
    log "Failed to auto generate config for version: ${CONFIG_VERSION}"
  else
    log "Auto generate config for version: ${CONFIG_VERSION}"
    log "Remove old config"
    rm "$1"
  fi
  unset config_auto_result

  # KLUDGE Duplication of code
  # We need this check in here too because our original loop does not
  # account for the fact that a new config was just added
  local new_config="$1.${CONFIG_VERSION}"
  base="$(basename "${new_config}" )"
  log "Check for match at (new_config): ${base} and (key): ${ssh_key}.${CONFIG_VERSION}"
  if [ "${base}" = "${ssh_key}.${CONFIG_VERSION}" ]; then
    __git_ssh_path="${new_config}"
    log "Set __git_ssh_path to: ${__git_ssh_path}"
    unset new_config
    break
  fi

  unset base
  unset new_config
}

locate_config_file()
{
  # Path expanstion via shell
  log "Find configs in ${config_dir}"
  for config in "${config_dir}"/*; do

    # Make sure we've found a config file, not folder
    log "Check that ${config} is a file, not folder"
    if [ ! -d "${config}" ]; then
      # Read the config if it is the one we want
      local base="$(basename "${config}" )"
      log "Check for match at (config): ${base} and (key): ${ssh_key}.${CONFIG_VERSION}"
      if [ "${base}" = "${ssh_key}" ]; then
        autoupdate_old_config "${config}"
      elif [ "${base}" = "${ssh_key}.${CONFIG_VERSION}" ]; then
        __git_ssh_path="${config}"
        log "Set __git_ssh_path to: ${__git_ssh_path}"
        break
      fi
      unset base
    fi
  done
}

check_valid_ssh_path()
{
  # If no matching key was found
  log "Check for __git_ssh_path: ${__git_ssh_path}"
  if [ -z "${__git_ssh_path}" ]; then
    printf -- "ERROR: No key found which matches the requested key: ${ssh_key}\n"
    return 1
  fi
}

prepare_create_config_option()
{
  if [ "${handled_by_create}" -ne 1 ]; then
    log "This git call is handled by create"
    handled_by_create=1
  fi

  if [ "${expect_create_config_name}" -ne 1 ]; then
    log "Expect create_config_name next..."
    expect_create_config_name=1
  fi
}

prepare_remove_config_name()
{
  if [ "${handled_by_remove}" -ne 1 ]; then
    log "This git call is handled by remove"
    handled_by_remove=1
  fi

  if [ "${expect_remove_config_name}" -ne 1 ]; then
    log "Expect remove_config_name next..."
    expect_remove_config_name=1
  fi
}

print_version()
{
  printf -- "git-ssh [${VERSION}]\n"
  echo
}

list_wrapper_help()
{
  print_version
  printf -- "options\n"
  echo
  printf -- "  --ssh CONFIG               The name identifier of a config file in the \${config_dir}.\n"
  printf -- "  --ssh-args COMMA-OPTIONS   Comma separated list of options to pass to ssh.\n"
  printf -- "  --config-dir DIR           The path to the directory where configs are stored.\n"
  printf -- "  --create-config NAME PATH  Create a config called NAME with\n"
  printf -- "                             the path PATH. Does not stop operation following completion.\n"
  printf -- "  --remove-config NAME       Remove the config specified by NAME.\n"
  printf -- "                             Does not stop operation following completion.\n"
  printf -- "  --list-configs             Lists the contents of the \${config_dir}.\n"
  printf -- "                             Stops operation following completion.\n"
  printf -- "  --wrapper-debug            Enables debugging statements\n"
  printf -- "  --wrapper-version          Prints the current wrapper version\n"
  printf -- "  --version                  Prints the current wrapper version followed by git --version\n"
  printf -- "  --wrapper-help             Prints only this help block\n"
  printf -- "  --help                     Prints this help block followed by git --help\n"
  echo
}

main()
{
  should_list_configs=0

  # Options to passthrough to git
  # KLUDGE not currently implemented
  #        See below in the switch statement
  #
  # git_options=""

  # We need git, cat, env, and ssh
  # In the case of git, we check that the path resolves
  if [ ! -e "${GIT_BINARY}" ]; then
    printf -- "Git must be installed and located at: ${GIT_BINARY}"
    exit 1
  fi

  check_for_binary cat
  check_for_binary ssh
  check_for_binary env

  # We have everything, let's go
  if [ -z "$1" ]; then
    # Just run git
    exec "${GIT_BINARY}" "$@"
  fi

  if [ $# -gt 0 ]; then
    long_option=
    long_option_has_arg=
    optind_expanded=
    eval optind_expanded="\$${OPTIND}"
    while [ -n "${optind_expanded}" ]; do
      log "CURRENT: $1"
      while getopts ":-:" option; do
        log "OPTION: ${option} ${OPTARG}"
        # Set only on long option with arg
        if [ -n "${long_option}" ]; then
          error_msg "Long option --${long_option} expects argument"
          return 1
        fi

        long_option=""
        case "${option}" in
          -)
            log "parse long option: -${option}${OPTARG}"
            case "${OPTARG}" in
              list-configs)
                handled_by_wrapper=1
                should_list_configs=1
                long_option_has_arg=0
                ;;
              wrapper-debug)
                long_option_has_arg=0
                handled_by_wrapper=0
                wrapper_debug=1
                log "Turn on wrapper debugging"
                ;;
              version|wrapper-version)
                long_option_has_arg=0
                handled_by_wrapper=1
                long_option="${OPTARG}"
                ;;
              help|wrapper-help)
                handled_by_wrapper=1
                long_option="${OPTARG}"
                long_option_has_arg=0
                ;;
              ssh|config-dir|remove-config|ssh-args|create-config)
                long_option_has_arg=1
                handled_by_wrapper=1
                long_option="${OPTARG}"
                ;;
            esac
            ;;
        esac
      done

      # Re-establish the current OPTIND target
      if [ $# -ge ${OPTIND} ]; then
        eval optind_expanded="\$${OPTIND}"
      else
        optind_expanded=""
      fi

      log "Continuing: ${long_option} | ${optind_expanded}"
      if [ -z "${optind_expanded}" ]; then
        if [ -n "${long_option}" ] && [ "${long_option_has_arg}" -eq 1 ]; then
          printf -- "Long option --${long_option} expects argument\n"
          return 1
        fi
      else
        if [ -z "${long_option}" ]; then
          log "No long option, pass arg to Git."
          log "Sanitize raw git argument: \"${optind_expanded}\""
          if [ -z "${git_args}" ]; then
            git_args="${optind_expanded}"
          else
            git_args="${git_args} ${optind_expanded}"
          fi
        elif [ "${long_option_has_arg}" -eq 0 ]; then
          # This is a plain arg and should be handled by one of the options which takes an argument
          log "Has option no argument: ${long_option}"
          case "${long_option}" in
            wrapper-help)
              list_wrapper_help
              return 0
              ;;
            help)
              list_wrapper_help
              exec "${GIT_BINARY}" ${git_args} --help
              ;;
            wrapper-debug)
              log "Turn on wrapper debugging"
              ;;
          esac
        else
          # This is a plain arg and should be handled by one of the options which takes an argument
          log "Has option with argument: ${long_option} ${optind_expanded}"
          case "${long_option}" in
            ssh)
              ssh_key="${optind_expanded}"
              ;;
            config-dir)
              config_dir="${optind_expanded}"
              ;;
            remove_config)
              remove_config_name="${optind_expanded}"
              handled_by_remove=1
              ;;
            ssh-args)
              handle_ssh_args_option "${optind_expanded}" || return 1
              ;;
            create-config)
              handle_create_config "${optind_expanded}" || return 1
              handled_by_create=1
              ;;
          esac
        fi
      fi

      # Set back to null
      long_option=
      long_option_has_arg=0

      # Shift the options
      shift $OPTIND
      OPTIND=1
    done
  fi

  # Remove the config if requested
  remove_config_if_wanted || exit 1

  # Create the config if requested
  create_config_if_wanted || exit 1

  if [ "${should_list_configs}" -ne 0 ]; then
    list_configs "${config_dir}" || exit 1
    exit 1
  fi

  # Wrapper does not play a part
  if [ "${handled_by_wrapper}" -eq 0 ]; then
    # Just run git
    # We use eval to convert the raw strings into arguments for git
    # This is not the safest solution but currently appears to work
    log "Call does not request wrapper options, call git normally"
    log "Do: \"${GIT_BINARY}\" ${git_args}"
    # shellcheck disable=SC2086
    exec "${GIT_BINARY}" ${git_args}
  fi

  # Make sure everything is set
  check_wrapper_conditions || exit 2

  # Read the config file requested and check its valid
  locate_config_file
  check_valid_ssh_path || exit 3

  # Run git using the ssh key that was found
  # Git will handle any errors related to a bad path
  # to an SSH key, just as if you had entered this env var yourself

  # We use eval to convert the raw strings into arguments for git
  # This is not the safest solution but currently appears to work
  #
  # Escape the double quotes so that the shell does not attempt to parse the
  # options given to GIT_SSH_COMMAND
  #
  # Escape the GIT_SSH_COMMAND with double quotes to allow paths with spaces
  # and single quotes to be passed through
  log "Call requests wrapper options, call wrapper git"
  log "GIT_SSH_COMMAND='ssh -F \"${__git_ssh_path}\" ${__ssh_args}'"
  log "GIT: ${GIT_BINARY}"
  log "ARGS: ${git_args}"
  eval "exec env GIT_SSH_COMMAND='ssh -F \"${__git_ssh_path}\" ${__ssh_args}' ${GIT_BINARY} ${git_args}"
}

main "$@"
# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:
