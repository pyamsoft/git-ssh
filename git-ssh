#!/bin/sh
#  Copyright (C) 2016 Peter Kenji Yamanaka
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# A bash script that wraps git calls to work with a specific SSH key

# git-ssh
# An ssh-key selection wrapper for git

# This will cause calls like:
#
# $ sh git-ssh
#
# to fail.
#
# Prevent the script from being sourced
# called_as="$(basename "$_")"
# if [ "${called_as}" != "git-ssh" ] && [ "${called_as}" != "git" ]; then
#   # Return, script was sourced
#   unset called_as
#   return 0
# fi
# unset called_as

# dash does not understand pipefail
#
# Fail if pipe fails
# set -o pipefail

# Export the LC as the default C so that we do not run into locale based quirks
export LC_ALL=C

# git-ssh
readonly VERSION="1.0.5"

# config file version
readonly CONFIG_VERSION="2"

# Location of the actual git binary
readonly GIT_BINARY="/usr/bin/git"

# List of plain arguments to pass to git
__git_args=""

# The ssh key git should use
__git_ssh_path=""

# No argument options
__wrapper_debug=0

# Parameters for creating a config
__create_config_name=""
__create_config_target=""

# Parameters for removing a config
__remove_config_name=""

log()
{
  if [ "${__wrapper_debug}" -ne 0 ]; then
    printf -- "%s\n" "$1"
  fi
}

##
# Check the environment path for the given binary, return if it is not found
#
# $1 the binary to check on the PATH
##
check_for_binary()
{
  check_for_binary__bin="$1"
  check_for_binary__old_ifs="${IFS}"
  if [ -z "${check_for_binary__bin}" ]; then
    printf -- "Must specify a path to a binary"
    return 1
  fi

  IFS=":"
  for check_for_binary__path in ${PATH}; do
    check_for_binary__result=
    check_for_binary__result="${check_for_binary__path}/${check_for_binary__bin}"
    if [ -e "${check_for_binary__result}" ]; then
      IFS="${check_for_binary__old_ifs}"

      unset check_for_binary__result
      unset check_for_binary__bin
      unset check_for_binary__old_ifs
      unset check_for_binary__path
      return 0
    fi

    unset check_for_binary__result
  done

  printf -- "Binary '${check_for_binary__bin}' not found in \$PATH"

  unset check_for_binary__result
  unset check_for_binary__bin
  unset check_for_binary__old_ifs
  unset check_for_binary__path
  return 1
}

##
# Handle the parsing of command line SSH arguments
#
# $1 ssh arguments, comma separated
#
# Outputs SSH arguments in correct format
handle_ssh_args_option()
{
  ssh_args_comma_separated="$1"
  ssh_args_correct=""
  split_ssh_args=

  check_for_binary tr || return 1
  split_ssh_args="$(printf -- "${ssh_args_comma_separated}" | tr "," "\n")"
  for arg in ${split_ssh_args}; do
    if [ -z "${ssh_args_correct}" ]; then
      ssh_args_correct="${arg}"
    else
      ssh_args_correct="${ssh_args_correct} ${arg}"
    fi
    unset arg
  done

  # Echo output
  log "ssh_args set to '${ssh_args_correct}'"
  printf -- "${ssh_args_correct}"

  unset ssh_args_comma_separated
  unset split_ssh_args
  return 0
}

##
# Prepares to create a config file given a format string
#
# $1 the format string [name]:[path]
handle_create_config()
{
  handle_create_config__args="$1"
  handle_create_config__split=""

  check_for_binary tr || return 1
  handle_create_config__split="$(printf -- "${handle_create_config__args}" | tr ":" "\n")"
  handle_create_config__i=0
  # shellcheck disable=SC2154
  for arg in ${handle_create_config__split}; do
    if [ ${handle_create_config__i} -ge 2 ]; then
      printf -- "Too many config arguments.\n"
      return 1
    elif [ ${handle_create_config__i} -eq 0 ]; then
      __create_config_name="${arg}"
      log "Set Config name: ${__create_config_name}"
    elif [ ${handle_create_config__i} -eq 1 ]; then
      __create_config_target="${arg}"
      log "Set Config target: ${__create_config_target}"
    fi
    handle_create_config__i=$((handle_create_config__i + 1))
  done

  if [ -z "${__create_config_name}" ] || [ -z "${__create_config_target}" ]; then
    printf -- "Either config name or target is not specified\n"
    return 1
  fi

  # Echo output
  log "Config name: ${__create_config_name}, target: ${__create_config_target}"
  printf -- "${__create_config_name}\n${__create_config_target}"

  unset handle_create_config__i
  unset handle_create_config__args
  unset split_config_args
  return 0
}

##
# Handle preparation for the removing of a config file
#
# $1 config directory
# $2 config target
handle_remove_config()
{
  handle_remove_config__dir="$1"
  handle_remove_config__file="$2"

  if [ ! -f "${handle_remove_config__dir}/${handle_remove_config__file}.${CONFIG_VERSION}" ]; then
    printf -- "Config does not exist, cannot remove."

    unset handle_remove_config__dir
    unset handle_remove_config__file
    return 1
  else
    log "Config file exists, set it"
    __remove_config_name="${handle_remove_config__file}"
  fi

  unset handle_remove_config__dir
  unset handle_remove_config__file
  return 0
}

##
# Process the creating of a config file
#
# $1 handled by create
# $2 config directory
create_config_if_wanted()
{
  create_config_if_wanted__handled="$1"
  create_config_if_wanted__dir="$2"

  if [ "${create_config_if_wanted__handled}" -ne 0 ]; then
    log "Create requested at ${__create_config_name}, ${__create_config_target}"
    if [ ! -z "${__create_config_name}" ] && [ ! -z "${__create_config_target}" ]; then
      check_config_dir_conditions "${create_config_if_wanted__dir}" || return 1
      create_config_if_wanted__file="${create_config_if_wanted__dir}/${__create_config_name}.${CONFIG_VERSION}"

      printf -- "Create new config: ${__create_config_name}\n"

      # Create the file
      touch "${create_config_if_wanted__file}"

      # Capture all hosts by default
      printf -- "Host *\n" > "${create_config_if_wanted__file}"

      # Set the requested identify file found at ${create_config_path}
      printf -- "    IdentityFile ${__create_config_target}\n" \
        >> "${create_config_if_wanted__file}"

      # Only use identities specified in the config file
      printf -- "    IdentitiesOnly yes\n" >> "${create_config_if_wanted__file}"

      unset create_config_if_wanted__file
    else
      printf -- "ERROR: Cannot create new config.\n"
      printf -- "    name: ${__create_config_name}\n"
      printf -- "    target: ${__create_config_target}\n"

      unset create_config_if_wanted__handled
      unset create_config_if_wanted__dir
      return 1
    fi
  fi

  unset create_config_if_wanted__handled
  unset create_config_if_wanted__dir
  return 0
}

##
# Process the removal of a config file
#
# $1 is handled by remove
# $1 config directory
remove_config_if_wanted()
{
  remove_config_if_wanted__handled="$1"
  remove_config_if_wanted__dir="$2"

  if [ "${remove_config_if_wanted__handled}" -ne 0 ]; then
    if [ ! -z "${__remove_config_name}" ]; then
      check_config_dir_conditions "${remove_config_if_wanted__dir}" || return 1
      check_for_binary rm || return 1
      remove_config_if_wanted__file="${remove_config_if_wanted__dir}/${__remove_config_name}.${CONFIG_VERSION}"

      rm -f "${remove_config_if_wanted__file}"
      printf -- "Remove config: ${remove_config_if_wanted__file}\n"

      unset remove_config_if_wanted__file
    else
      printf -- "ERROR: No config specified.\n"

      unset remove_config_if_wanted__dir
      unset remove_config_if_wanted__handled
      return 1
    fi
  fi

  unset remove_config_if_wanted__dir
  unset remove_config_if_wanted__handled
  return 0
}

##
# List all existing git-ssh configurations
#
# $1 configuration directory
list_configs()
{
  list_configs__config_dir="$1"
  check_config_dir_conditions || return 1
  check_for_binary ls || return 1
  check_for_binary wc || return 1
  check_for_binary head || return 1

  list_configs__count=
  # shellcheck disable=SC2012
  list_configs__count=$(ls -1 "${list_configs__config_dir}" | wc -l)
  printf -- "Config directory: ${list_configs__config_dir}\n"
  printf -- "Number of configs: ${list_configs__count}\n"

  echo
  for list_configs__file in "${list_configs__config_dir}"/*; do
    printf -- "[$(basename "${list_configs__file}")]\n"
    printf -- "Path: $(cat "${list_configs__file}" )\n"
    echo
  done

  unset list_configs__config_dir
  unset list_configs__count
  return 0
}

##
# Check that the configuration directory exists
#
# $1 configuration directory
check_config_dir_conditions()
{
  check_config_dir_conditions__dir="$1"

  # No config dir specified
  log "Check for set config dir..."
  if [ -z "${check_config_dir_conditions__dir}" ]; then
    printf -- "ERROR: No config_dir specified\n"

    unset check_config_dir_conditions__dir
    return 1
  fi

  # Check for the existance of the config file
  log "Check that config dir exists as a directory..."
  if [ ! -d "${check_config_dir_conditions__dir}" ]; then
    printf -- "ERROR: config_dir does not exist at:  ${check_config_dir_conditions__dir}\n"

    unset check_config_dir_conditions__dir
    return 1
  fi

  unset check_config_dir_conditions__dir
  return 0
}

##
# Check that the ssh_key is defined
#
# $1 ssh_key variable
check_ssh_key_conditions()
{
  check_ssh_key_conditions__ssh="$1"

  log "Check that an ssh_key was requested..."
  if [ -z "${check_ssh_key_conditions__ssh}" ]; then
    # No ssh key was requested
    printf -- "ERROR: No ssh_key was requested\n"
    return 1
  fi

  unset check_ssh_key_conditions__ssh
  return 0
}

##
# Check that the wrapper can continue
#
# $1 configuration directory
# $2 ssh_key variable
check_wrapper_conditions()
{
  check_wrapper_conditions__config="$1"
  check_wrapper_conditions__ssh="$2"

  log "Check that wrapper can continue..."
  check_config_dir_conditions "${check_wrapper_conditions__config}"|| return 1
  check_ssh_key_conditions "${check_wrapper_conditions__ssh}" || return 1

  unset check_wrapper_conditions__config
  return 0
}

##
# Auto update an old config file from version 1 to 2
#
# $1 config file directory
# $2 config file name
autoupdate_old_config()
{
  autoupdate_old_config__dir="$1"
  autoupdate_old_config__config="$2"
  autoupdate_old_config__base_config="$(basename "${autoupdate_old_config__config}")"

  # Upgrading from git-ssh config version 1
  log "Old config file found at: ${autoupdate_old_config__base_config}"
  log "Auto upgrade to new format"
  check_for_binary head || return 1

  # Get the old ssh_path from the original config file
  autoupdate_old_config__old="$(head -n 1 < "${autoupdate_old_config__config}" )"
  autoupdate_old_config__mashup="${autoupdate_old_config__base_config}:${autoupdate_old_config__old}"
  log "Run artificial call: handle_create_config ${autoupdate_old_config__mashup}"
  handle_create_config "${autoupdate_old_config__mashup}" || return 1

  create_config_if_wanted "${autoupdate_old_config__dir}"
  if [ $? -ne 0 ]; then
    log "Failed to auto generate config for version: ${CONFIG_VERSION}"

    unset autoupdate_old_config__config
    unset autoupdate_old_config__dir
    unset autoupdate_old_config__base_config
    unset autoupdate_old_config__old
    unset autoupdate_old_config__mashup
    return 1
  else
    log "Auto generate config for version: ${CONFIG_VERSION}"
    log "Remove old config"
    check_for_binary rm || return 1
    rm -f "$1"
  fi

  # Set the __git_ssh_path
  __git_ssh_path="${autoupdate_old_config__config}.${CONFIG_VERSION}"
  log "Set __git_ssh_path to: ${__git_ssh_path}"

  unset autoupdate_old_config__config
  unset autoupdate_old_config__dir
  unset autoupdate_old_config__base_config
  unset autoupdate_old_config__old
  unset autoupdate_old_config__mashup
  return 0
}

##
# Locate all the configurations in the config_dir
#
# $1 configuration directory
# $2 ssh key
locate_config_file()
{
  locate_config_file__dir="$1"
  locate_config_file__ssh="$2"

  # Path expanstion via shell
  log "Find configs in ${locate_config_file__dir}"
  for locate_config_file__config in "${locate_config_file__dir}"/*; do

    # Make sure we've found a config file, not folder
    log "Check that ${locate_config_file__config} is a file, not folder"
    if [ ! -d "${locate_config_file__config}" ]; then
      # Read the config if it is the one we want
      locate_config_file__base_config="$(basename "${locate_config_file__config}")"
      log "Check for match at (config): ${locate_config_file__base_config} and (key): ${locate_config_file__ssh}.${CONFIG_VERSION}"
      if [ "${locate_config_file__base_config}" = "${locate_config_file__ssh}" ]; then
        autoupdate_old_config "${locate_config_file__dir}" "${locate_config_file__config}" || return 1
      elif [ "${locate_config_file__base_config}" = "${locate_config_file__ssh}.${CONFIG_VERSION}" ]; then
        __git_ssh_path="${locate_config_file__config}"
        log "Set __git_ssh_path to: ${__git_ssh_path}"
        break
      fi
      unset locate_config_file__base_config
    fi

    unset locate_config_file__config
  done

  unset locate_config_file__dir
  unset locate_config_file__ssh
  return 0
}

##
# Check that the ssh_path exists
#
# $1 ssh_key name
check_valid_ssh_path()
{
  check_valid_ssh_path__name="$1"

  # If no matching key was found
  log "Check for __git_ssh_path: ${__git_ssh_path}"
  if [ -z "${__git_ssh_path}" ]; then
    printf -- "ERROR: No key found which matches the requested key: ${check_valid_ssh_path__name}\n"
    return 1
  fi

  unset check_valid_ssh_path__name
  return 0
}

##
# Print current version
#
print_version()
{
  printf -- "git-ssh [${VERSION}]\n"
  echo

  return 0
}

##
# Print wrapper centric help
#
list_wrapper_help()
{
  print_version
  printf -- "options\n"
  echo
  printf -- "  --ssh CONFIG               The name identifier of a config file in the \${config_dir}.\n"
  printf -- "  --ssh-args COMMA-OPTIONS   Comma separated list of options to pass to ssh.\n"
  printf -- "  --config-dir DIR           The path to the directory where configs are stored.\n"
  printf -- "  --create-config NAME:PATH  Create a config called NAME with\n"
  printf -- "                             the path PATH. Does not stop operation following completion.\n"
  printf -- "  --remove-config NAME       Remove the config specified by NAME.\n"
  printf -- "                             Does not stop operation following completion.\n"
  printf -- "  --list-configs             Lists the contents of the \${config_dir}.\n"
  printf -- "                             Stops operation following completion.\n"
  printf -- "  --wrapper-debug            Enables debugging statements\n"
  printf -- "  --wrapper-version          Prints the current wrapper version\n"
  printf -- "  --version                  Prints the current wrapper version followed by git --version\n"
  printf -- "  --wrapper-help             Prints only this help block\n"
  printf -- "  --help                     Prints this help block followed by git --help\n"
  echo

  return 0
}

##
# Appends a plain argument to the list that is passed through to $GIT_BINARY
#
# $1 argument
append_git_argument()
{
  append_git_argument__arg="$1"

  log "Sanitize raw git argument: \"${append_git_argument__arg}\""
  if [ -z "${__git_args}" ]; then
    __git_args="\"${append_git_argument__arg}\""
  else
    __git_args="${__git_args} \"${append_git_argument__arg}\""
  fi

  unset append_git_argument__arg
  return 0
}

##
# Main function
#
# $@ command line arguments
main()
{
  # handlers
  handled_by_wrapper=0
  handled_by_create=0
  handled_by_remove=0
  should_list_configs=0

  ssh_key=""
  ssh_args=""

  # Location of the dir with configs stored
  config_dir="$XDG_CONFIG_HOME/git-ssh"

  # We need git, cat, env, and ssh
  # In the case of git, we check that the path resolves
  if [ ! -e "${GIT_BINARY}" ]; then
    printf -- "Git must be installed and located at: ${GIT_BINARY}"
    return 1
  fi

  check_for_binary cat
  check_for_binary ssh
  check_for_binary env

  # We have everything, let's go
  if [ -z "$1" ]; then
    # Just run git
    exec "${GIT_BINARY}" "$@"
  fi

  if [ $# -gt 0 ]; then
    long_option=
    long_option_has_arg=
    optind_expanded=
    eval optind_expanded="\$${OPTIND}"
    while [ -n "${optind_expanded}" ]; do
      log "CURRENT: $1"
      while getopts ":-:" option; do
        log "OPTION: ${option} ${OPTARG}"
        # Set only on long option with arg
        if [ -n "${long_option}" ]; then
          error_msg "Long option --${long_option} expects argument"
          return 1
        fi

        long_option=""
        case "${option}" in
          -)
            log "parse long option: -${option}${OPTARG}"
            case "${OPTARG}" in
              list-configs)
                handled_by_wrapper=1
                should_list_configs=1
                long_option_has_arg=0
                ;;
              wrapper-debug)
                long_option_has_arg=0
                __wrapper_debug=1
                log "Turn on wrapper debugging"
                ;;
              wrapper-version)
                long_option_has_arg=0
                long_option="${OPTARG}"
                ;;
              wrapper-help)
                long_option="${OPTARG}"
                long_option_has_arg=0
                ;;
              create-config)
                long_option_has_arg=1
                handled_by_create=1
                long_option="${OPTARG}"
                ;;
              remove-config)
                long_option_has_arg=1
                handled_by_remove=1
                long_option="${OPTARG}"
                ;;
              ssh|config-dir|ssh-args)
                long_option_has_arg=1
                handled_by_wrapper=1
                long_option="${OPTARG}"
                ;;
              *)
                log "Long option that is not handled by script passed."
                append_git_argument "--${OPTARG}" || return 1
                ;;
            esac
            ;;
          *)
            log "Git option, pass arg to Git."
            append_git_argument "-${OPTARG}" || return 1
            ;;
        esac
      done

      # Re-establish the current OPTIND target
      if [ $# -ge ${OPTIND} ]; then
        eval optind_expanded="\$${OPTIND}"
      else
        optind_expanded=""
      fi

      log "Continuing: ${long_option} | ${optind_expanded}"
      if [ -n "${long_option}" ]; then
        # Call should be processed by wrapper
        if [ "${long_option_has_arg}" -eq 1 ]; then
          if [ -z "${optind_expanded}" ]; then
            printf -- "Long option --${long_option} expects argument\n"
            return 1
          fi

          # This is a plain arg and should be handled by one of the options which takes an argument
          log "Has option with argument: ${long_option} ${optind_expanded}"
          case "${long_option}" in
            ssh)
              ssh_key="${optind_expanded}"
              ;;
            config-dir)
              config_dir="${optind_expanded}"
              ;;
            remove-config)
              handle_remove_config "${optind_expanded}" || return 1
              ;;
            ssh-args)
              ssh_args="$(handle_ssh_args_option "${optind_expanded}")" || return 1
              ;;
            create-config)
              handle_create_config "${optind_expanded}" || return 1
              ;;
          esac
        else
          # This is a plain arg and should be handled by one of the options which takes an argument
          log "Has option no argument: ${long_option}"
          case "${long_option}" in
            wrapper-help)
              list_wrapper_help || return 1
              return 0
              ;;
            # Do not override git calls
            #
            # help)
            #   list_wrapper_help || return 1
            #   eval "exec ${GIT_BINARY} ${__git_args} --help"
            #   ;;
            wrapper-version)
              print_version || return 1
              return 0
              ;;
            # Do not override git calls
            #
            # version)
            #   print_version || return 1
            #   eval "exec ${GIT_BINARY} ${__git_args} --version"
            #   ;;
            wrapper-debug)
              log "Turn on wrapper debugging"
              ;;
          esac
        fi
      else
        if [ -n "${optind_expanded}" ]; then
          # Just pass argument to git
          log "No option, pass arg to Git."
          append_git_argument "${optind_expanded}" || return 1
        else
          log "No argument passed"
        fi
      fi

      # Set back to null
      long_option=
      long_option_has_arg=0

      option_shift_count="${OPTIND}"
      log "Option count: $#"
      log "If possible, shift by: ${option_shift_count}"
      while [ "$#" -lt "${option_shift_count}" ]; do
        log "Shift count is too large, decrement"
        option_shift_count=$((option_shift_count - 1))
        log "If possible, shift by: ${option_shift_count}"
      done

      # Need this here incase the loop doesn't run
      if [ "$#" -ge "${option_shift_count}" ]; then
        # Shift the options
        log "Shift by: ${option_shift_count}"
        shift ${option_shift_count}
        OPTIND=1
      fi

      # Unset
      unset option_shift_count
    done
  fi

  log "After loop argument count: $#"
  log "After loop OPTIND count: ${OPTIND}"

  # Remove the config if requested
  remove_config_if_wanted "${handled_by_remove}" "${config_dir}" || return 1

  # Create the config if requested
  create_config_if_wanted "${handled_by_create}" "${config_dir}" || return 1

  if [ "${should_list_configs}" -ne 0 ]; then
    list_configs "${config_dir}" || return 1
    return 1
  fi

  # Wrapper does not play a part
  if [ "${handled_by_wrapper}" -eq 0 ]; then
    # Just run git
    log "Call does not request wrapper options, call git normally"
    log "Do: \"${GIT_BINARY}\" ${__git_args}"
    eval "exec ${GIT_BINARY} ${__git_args}"
  fi

  # Make sure everything is set
  check_wrapper_conditions "${config_dir}" "${ssh_key}" || return 1

  # Read the config file requested and check its valid
  locate_config_file "${config_dir}" "${ssh_key}" || return 1
  check_valid_ssh_path "${ssh_key}"|| return 1

  # Run git using the ssh key that was found
  # Git will handle any errors related to a bad path
  # to an SSH key, just as if you had entered this env var yourself

  # Escape the double quotes so that the shell does not attempt to parse the
  # options given to GIT_SSH_COMMAND
  #
  # Escape the GIT_SSH_COMMAND with double quotes to allow paths with spaces
  # and single quotes to be passed through
  log "Call requests wrapper options, call wrapper git"
  log "GIT_SSH_COMMAND='ssh -F \"${__git_ssh_path}\" ${ssh_args}'"
  log "GIT: ${GIT_BINARY}"
  log "ARGS: ${__git_args}"
  export GIT_SSH_COMMAND="ssh -F \"${__git_ssh_path}\" ${ssh_args}"

  eval "exec ${GIT_BINARY} ${__git_args}"
}

main "$@" || exit 1
# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:
