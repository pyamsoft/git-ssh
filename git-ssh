#!/bin/sh
#  Copyright (C) 2016 Peter Kenji Yamanaka
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# A bash script that wraps git calls to work with a specific SSH key

# git-ssh
# An ssh-key selection wrapper for git

# NOTE: This script does not check that the SSH key is valid, and does not
# sanitize input. Please make sure all input passed into the script is
# valid either in the context of the script or the git binary itself

# git-ssh
version="0.2.0"

# CONFIGURATION
#
# A valid config file can take any name, with or without spaces, and can
# have any extension, though normal convention is to have none. For any
# config files with spaces in the name, they will need to be properly
# escaped.
#
# Examples:     rsa    "second key"   github.ssh.key
#
# A valid config file consists of exactly one line of content: A path
# to an ssh key. While a relative path will work, it is generally recommended
# that one uses absolute paths to be clear as to which key is being requested.
# Comments are not allowed in the config file, in any kind of syntax.
# Any variables in the config file will be interpreted by the shell.
#
# Example:
# In example config file <rsa>
# ~/.ssh/id_rsa
#
# In example config file <"second key">
# ${HOME}/.ssh/id_dsa

# Location of the actual git binary
_git="/usr/bin/git"

# Location of the dir with configs stored
config_dir="$XDG_CONFIG_HOME/git-ssh"

# The ssh key requested
ssh_key=""

# The ssh key git should use
git_ssh_path=""

# Parameters for creating a new configuration
create_config_name=""
create_config_path=""

# Is this call to git going to be handled by the wrapper
handled_by_wrapper=0
handled_by_create=0

# These are set when the next passed in argument is expected
# to be a valid parameter
expect_ssh_key=0
expect_config_dir=0
expect_create_config_name=0
expect_create_config_path=0

# Check the environment path for the given binary, exit if it is not found
check_for_binary()
{
  if ! which "$1" > /dev/null 2>&1; then
    printf -- "The '%s' binary is required for this script.\n" "$1"
    printf -- "Please install '%s' onto your system.\n" "$1"
    exit 1
  fi
}

# Sets the ssh_key
handle_ssh_key_option()
{
  expect_ssh_key=0
  ssh_key="$1"
}

# Sets the config_dir
handle_config_dir_option()
{
  expect_config_dir=0
  config_dir="$1"
}

handle_create_config_name()
{
  expect_create_config_name=0
  expect_create_config_path=1
  create_config_name="$1"
}

handle_create_config_path()
{
  expect_create_config_path=0
  create_config_path="$1"
}

prepare_ssh_key_option()
{
  # Handle this call to git with the wrapper
  if [ "${handled_by_wrapper}" -ne 1 ]; then
    handled_by_wrapper=1
  fi

  if [ "${expect_ssh_key}" -ne 1 ]; then
    expect_ssh_key=1
  fi
}

prepare_config_dir_option()
{
  # Handle this call to git with the wrapper
  if [ "${handled_by_wrapper}" -ne 1 ]; then
    handled_by_wrapper=1
  fi

  if [ "${expect_config_dir}" -ne 1 ]; then
    expect_config_dir=1
  fi
}

create_config_if_wanted()
{
  if [ "${handled_by_create}" -ne 0 ]; then
    if [ ! -z "${create_config_name}" ] && [ ! -z "${create_config_path}" ]; then
      check_config_dir_conditions || return 1
      printf -- "${create_config_path}\n" > "${config_dir}/${create_config_name}"
      printf -- "Create new config: ${create_config_name}\n"
    else
      printf -- "ERROR: Cannot create new config.\n"
      printf -- "    name: ${create_config_name}\n"
      printf -- "    path: ${create_config_path}\n"
      return 2
    fi
  fi
}

check_config_dir_conditions()
{
  # No config dir specified
  if [ -z "${config_dir}" ]; then
    printf -- "ERROR: No config_dir specified\n"
    return 1
  fi

  # Check for the existance of the config file
  if [ ! -d ${config_dir} ]; then
    printf -- "ERROR: config_dir does not exist at:  ${config_dir}\n"
    return 2
  fi
}

check_ssh_key_conditions()
{
  # No ssh key was requested
  if [ -z "${ssh_key}" ]; then
    printf -- "ERROR: No ssh_key was requested\n"
    return 1
  fi
}

check_wrapper_conditions()
{
  check_config_dir_conditions || return 1
  check_ssh_key_conditions || return 2
}

read_config_file()
{
  # Path expanstion via shell
  for config in "${config_dir}"/*; do

    # Make sure we've found a config file, not folder
    if [ ! -d "${config}" ]; then
      # Read the config if it is the one we want
      if [ "$(basename ${config})" = "${ssh_key}" ]; then
        git_ssh_path=$(cat "$config")
        break
      fi
    fi
  done
}

check_valid_ssh_path()
{
  # If no matching key was found
  if [ -z "${git_ssh_path}" ]; then
    printf -- "ERROR: No key found which matches the requested key: ${ssh_key}\n"
    return 1
  fi
}

prepare_create_config_option()
{
  if [ "${handled_by_create}" -ne 1 ]; then
    handled_by_create=1
  fi

  if [ "${expect_create_config_name}" -ne 1 ]; then
    expect_create_config_name=1
  fi
}

display_wrapper_help()
{
  printf -- "git-ssh\n"
  echo
  printf -- "options\n"
  echo
  printf -- "    --ssh CONFIG      The name identifier of a config\n"
  printf -- "                      file in the ${config_dir}.\n"
  printf -- "    --config-dir DIR  The path to the directory where configs\n"
  printf -- "                      are stored\n"
}

# Options to passthrough to git
# KLUDGE not currently implemented
#        See below in the switch statement
#
# git_options=""

# We need git, cat, env, and ssh
# In the case of git, we check that the path resolves
check_for_binary "${_git}"
check_for_binary cat
check_for_binary ssh
check_for_binary env

# We have everything, let's go
if [ -z "$1" ]; then
  # Just run git
  exec "${_git}" "$@"
fi

# Super hacky option parsing
# Loop through the options passed in var $@
# If the option is a valid case in the switch statement
# it will set an expected_$$ flag
#
# If the flag is set, the next variable passed in is expected to be
# a valid parameter for the given option.
# The option call --${opt} and its argument ${arg} are shifted out of the
# array $@ so that only the options passed to git are left
for option in "$@"; do

  # Check for any expected options
  if [ "${expect_ssh_key}" -ne 0 ]; then
    handle_ssh_key_option "${option}"
    shift
    continue
  elif [ "${expect_config_dir}" -ne 0 ]; then
    handle_config_dir_option "${option}"
    shift
    continue
  elif [ "${expect_create_config_name}" -ne 0 ]; then
    handle_create_config_name "${option}"
    shift
    continue
  elif [ "${expect_create_config_path}" -ne 0 ]; then
    handle_create_config_path "${option}"
    shift
    continue
  fi

  case "${option}" in
    "--ssh")
      prepare_ssh_key_option
      shift
      ;;
    "--config-dir")
      prepare_config_dir_option
      shift
      ;;
    "--create-config")
      prepare_create_config_option
      shift
      ;;
    "--wrapper-help")
      display_wrapper_help
      # The help call ends the script
      exit 0
      ;;
    *)
      # git_options="$1 ${git_options}"
      # shift

      # KLUDGE Limiations
      # Do nothing
      ;;
  esac
done

# Create the config if requested
create_config_if_wanted || exit 1

# Wrapper does not play a part
if [ "${handled_by_wrapper}" -eq 0 ]; then
  # Just run git
  exec "${_git}" "$@"
fi

# Make sure everything is set
check_wrapper_conditions || exit 2

# Read the config file requested and check its valid
read_config_file
check_valid_ssh_path || exit 3

# Run git using the ssh key that was found
# Git will handle any errors related to a bad path
# to an SSH key, just as if you had entered this env var yourself

# exec env GIT_SSH_COMMAND="ssh -i ${git_ssh_path}" "${_git}" "${git_options}"
exec env GIT_SSH_COMMAND="ssh -i ${git_ssh_path}" "${_git}" "$@"

# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:
