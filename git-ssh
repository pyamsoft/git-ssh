#!/bin/sh
#  Copyright (C) 2016 Peter Kenji Yamanaka
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# A bash script that wraps git calls to work with a specific SSH key

# git-ssh
# An ssh-key selection wrapper for git

# NOTE: This script does not check that the SSH key is valid, and does not
# sanitize input. Please make sure all input passed into the script is
# valid either in the context of the script or the git binary itself

# git-ssh
version="0.1.0"

# options
# The script currently handles the following option(s):
#
# --ssh CONFIG   The name identifier of a config file in the ${config_dir}
#                The contents expected in the CONFIG file are listed in the
#                CONFIGURATION section
#
#
# CONFIGURATION
#
# A valid config file can take any name, with or without spaces, and can
# have any extension, though normal convention is to have none. For any
# config files with spaces in the name, they will need to be properly
# escaped.
#
# Examples:     rsa    "second key"   github.ssh.key
#
# A valid config file consists of exactly one line of content: A path
# to an ssh key. While a relative path will work, it is generally recommended
# that one uses absolute paths to be clear as to which key is being requested.
# Comments are not allowed in the config file, in any kind of syntax.
# Any variables in the config file will be interpreted by the shell.
#
# Example:
# In example config file <rsa>
# ~/.ssh/id_rsa
#
# In example config file <"second key">
# ${HOME}/.ssh/id_dsa


# Check the environment path for the given binary, exit if it is not found
check_for_binary()
{
  if ! which "$1" > /dev/null 2>&1; then
    printf -- "The '%s' binary is required for this script.\n" "$1"
    printf -- "Please install '%s' onto your system.\n" "$1"

    # Error code 1: Missing binary
    exit 1
  fi
}

# Location of the actual git binary
_git="/usr/bin/git"

# Location of the dir with configs stored
config_dir="$XDG_CONFIG_HOME/git-ssh"

# The ssh key requested
ssh_key=""

# Is this call to git going to be handled by the wrapper
handled_by_wrapper=0

# These are set when the next passed in argument is expected
# to be a valid parameter
expect_ssh_key=0
expect_config_dir=0

# Options to passthrough to git
# KLUDGE not currently implemented
#        See below in the switch statement
#
# git_options=""

# We need git, cat, env, and ssh
# In the case of git, we check that the path resolves
check_for_binary "${_git}"
check_for_binary cat
check_for_binary ssh
check_for_binary env

# We have everything, let's go
if [ -z "$1" ]; then
  # Just run git
  exec "${_git}" "$@"
fi

# Super hacky option parsing
# Loop through the options passed in var $@
# If the option is a valid case in the switch statement
# it will set an expected_$$ flag
#
# If the flag is set, the next variable passed in is expected to be
# a valid parameter for the given option.
# The option call --${opt} and its argument ${arg} are shifted out of the
# array $@ so that only the options passed to git are left
for option in "$@"; do

  # Check for any expected options
  if [ "${expect_ssh_key}" -ne 0 ]; then
    expect_ssh_key=0
    ssh_key="${option}"
    shift
    continue
  elif [ "${expect_config_dir}" -ne 0 ]; then
    expect_config_dir=0
    config_dir="${option}"
    shift
    continue
  fi

  case "${option}" in
    "--ssh")
      # Handle this call to git with the wrapper
      if [ "${handled_by_wrapper}" -ne 1 ]; then
        handled_by_wrapper=1
      fi

      # Eat the current $1
      shift

      if [ "${expect_ssh_key}" -ne 1 ]; then
        expect_ssh_key=1
      fi
      ;;
    "--config-dir")
      # Handle this call to git with the wrapper
      if [ "${handled_by_wrapper}" -ne 1 ]; then
        handled_by_wrapper=1
      fi

      # Eat the current $1
      shift

      if [ "${expect_config_dir}" -ne 1 ]; then
        expect_config_dir=1
      fi
      ;;
    *)
      # git_options="$1 ${git_options}"
      # shift

      # KLUDGE Limiations
      # Do nothing
      ;;
  esac
done

# Wrapper does not play a part
if [ "${handled_by_wrapper}" -eq 0 ]; then
  # Just run git
  exec "${_git}" "$@"
fi

# No config dir specified
if [ -z "${config_dir}" ]; then
  printf -- "ERROR: No config_dir specified\n"
  exit 2
fi

# No ssh key was requested
if [ -z "${ssh_key}" ]; then
  printf -- "ERROR: No ssh_key was requested\n"
  exit 3
fi

# An ssh key is requested

# Check for the existance of the config file
if [ ! -d ${config_dir} ]; then
  printf -- "ERROR: config_dir does not exist at:  ${config_dir}\n"
  exit 4
fi

# The ssh key git should use
git_ssh_path=""

# Go into the config dir

# Path expanstion via shell
for config in "${config_dir}"/*; do

  # Make sure we've found a config file, not folder
  if [ ! -d "${config}" ]; then
    # Read the config if it is the one we want
    if [ "$(basename ${config})" = "${ssh_key}" ]; then
      git_ssh_path=$(cat "$config")
      break
    fi
  fi
done

# If no matching key was found
if [ -z "${git_ssh_path}" ]; then
  printf -- "ERROR: No key found which matches the requested key: ${ssh_key}\n"

  # Error code 3: Bad key requested
  exit 3
fi

# Run git using the ssh key that was found
# Git will handle any errors related to a bad path
# to an SSH key, just as if you had entered this env var yourself

# exec env GIT_SSH_COMMAND="ssh -i ${git_ssh_path}" "${_git}" "${git_options}"
exec env GIT_SSH_COMMAND="ssh -i ${git_ssh_path}" "${_git}" "$@"

# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:
