#!/bin/sh
#  Copyright (C) 2016 Peter Kenji Yamanaka
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# A bash script that wraps git calls to work with a specific SSH key

# git-ssh
# An ssh-key selection wrapper for git

# This will cause calls like:
#
# $ sh git-ssh
#
# to fail.
#
# Prevent the script from being sourced
# called_as="$(basename "$_")"
# if [ "${called_as}" != "git-ssh" ] && [ "${called_as}" != "git" ]; then
#   # Return, script was sourced
#   unset called_as
#   return 0
# fi
# unset called_as

# dash does not understand pipefail
#
# Fail if pipe fails
# set -o pipefail

##
# Encode items into an array
array_encode()
{
  sed 's/%/%25/g' | sed -e :a -e '$!N; s/\n/%0A/; ta'
}

##
# Inverse function of array_encode.
#
array_decode() {
  # shellcheck disable=SC1004
  sed -e 's/%0[aA]/\
/g' -e 's/%25/%/g'
}

##
# Append items to an array
#
# Pass your array as the first argument:
#   array_append "$A" 'next' 'another'
array_append () {
  printf -- "%s\n" "$1" && shift &&
  for i in "$@" ; do
    printf -- "%s\n" "$i" | array_encode
  done
}

##
# Creates an array with arbitrary amount of elements
array_create()
{
  for i in "$@"; do
    printf -- "%s\n" "$i" | array_encode
  done
}

log()
{
  if [ "$#" -eq 0 ]; then
    return 1
  fi

  if [ "${__wrapper_debug}" -ne 0 ]; then
    log__fmt="$1"
    shift
    # shellcheck disable=SC2059
    printf -- "${log__fmt}\n" "$@"
    unset log__fmt
  fi

  return 0
}

##
# Check the environment path for the given binary, return if it is not found
#
# $1 the binary to check on the PATH
##
check_binary()
{
  check_binary__bin="$1"
  if [ -z "${check_binary__bin}" ]; then
    # Really hope we at least have printf
    printf -- "Must specify a path to a binary\n"
    unset check_binary__bin
    return 1
  fi

  if command -v "${check_binary__bin}" > /dev/null 2>&1; then
    unset check_binary__bin
    return 0
  else
    # Really hope we at least have printf
    printf -- "Binary '%s' not found in \$PATH\n" "${check_binary__bin}"
    unset check_binary__bin
    return 1
  fi
}

##
# Handle the parsing of command line SSH arguments
#
# $1 ssh arguments, comma separated
#
# Outputs SSH arguments in correct format
handle_ssh_args_option()
{
  ssh_args_comma_separated="$1"
  ssh_args_correct=""
  split_ssh_args=

  check_binary tr || return 1
  split_ssh_args="$(printf -- "%s" "${ssh_args_comma_separated}" | tr "," "\n")"
  for arg in ${split_ssh_args}; do
    if [ -z "${ssh_args_correct}" ]; then
      ssh_args_correct="${arg}"
    else
      ssh_args_correct="${ssh_args_correct} ${arg}"
    fi
    unset arg
  done

  # Echo output
  log "ssh_args set to '%s'" "${ssh_args_correct}"
  printf -- "%s" "${ssh_args_correct}"

  unset ssh_args_comma_separated
  unset split_ssh_args
  return 0
}

##
# Prepares to create a config file given a format string
#
# $1 the format string [name]:[path]
handle_create_config()
{
  handle_create_config__args="$1"
  handle_create_config__split=""

  check_binary tr || return 1
  handle_create_config__split="$(printf -- "%s" \
    "${handle_create_config__args}" | tr ":" "\n")"
  handle_create_config__i=0
  for arg in ${handle_create_config__split}; do
    log "Create argument: %s" "${arg}"
    if [ ${handle_create_config__i} -ge 2 ]; then
      printf -- "Too many config arguments.\n"
      return 1
    elif [ ${handle_create_config__i} -eq 0 ]; then
      __create_config_name="${arg}"
      log "Set Config name: %s" "${__create_config_name}"
    elif [ ${handle_create_config__i} -eq 1 ]; then
      __create_config_target="${arg}"
      log "Set Config target: %s" "${__create_config_target}"
    fi
    handle_create_config__i=$((handle_create_config__i + 1))
  done

  if [ -z "${__create_config_name}" ] \
    || [ -z "${__create_config_target}" ]; then
    printf -- "Either config name or target is not specified\n"
    return 1
  fi

  log "Config name: %s, target: %s" "${__create_config_name}" \
    "${__create_config_target}"

  unset handle_create_config__i
  unset handle_create_config__args
  unset split_config_args
  return 0
}

##
# Handle preparation for the removing of a config file
#
# $1 config directory
# $2 config target
handle_remove_config()
{
  handle_remove_config__dir="$1"
  handle_remove_config__file="$2"
  handle_remove_config__check="$(cat << EOF
${handle_remove_config__dir}/${handle_remove_config__file}.${CONFIG_VERSION}
EOF
)"

  log "Check for file exists: %s" "${handle_remove_config__check}"
  if [ ! -f "${handle_remove_config__check}" ]; then
    printf -- "Config does not exist, cannot remove.\n"

    unset handle_remove_config__dir
    unset handle_remove_config__file
    unset handle_remove_config__check
    return 1
  else
    log "Config file exists, set it"
    __remove_config_name="${handle_remove_config__file}"
  fi

  unset handle_remove_config__check
  unset handle_remove_config__dir
  unset handle_remove_config__file
  return 0
}

##
# Process the creating of a config file
#
# $1 handled by create
# $2 config directory
create_config_if_wanted()
{
  create_config_if_wanted__handled="$1"
  create_config_if_wanted__dir="$2"

  if [ "${create_config_if_wanted__handled}" -ne 0 ]; then
    log "Create requested at %s, %s" "${__create_config_name}" \
      "${__create_config_target}"
    if [ ! -z "${__create_config_name}" ] \
      && [ ! -z "${__create_config_target}" ]; then
      check_config_dir_conditions "${create_config_if_wanted__dir}" \
        || return 1
      create_config_if_wanted__file="$(cat << EOF
${create_config_if_wanted__dir}/${__create_config_name}.${CONFIG_VERSION}
EOF
)"

      printf -- "Create new config: %s\n" "${__create_config_name}"

      # Create the file
      touch "${create_config_if_wanted__file}"

      # Capture all hosts by default
      printf -- "Host *\n" > "${create_config_if_wanted__file}"

      {
        printf -- "    IdentityFile %s\n" "${__create_config_target}"

        # Only use identities specified in the config file
        printf -- "    IdentitiesOnly yes\n"

        # Leave this option commented out by default
        printf -- "    # AddKeysToAgent yes\n"
      } >> "${create_config_if_wanted__file}"

      unset create_config_if_wanted__file
    else
      printf -- "ERROR: Cannot create new config.\n"
      printf -- "    name: %s\n" "${__create_config_name}"
      printf -- "    target: %s\n" "${__create_config_target}"

      unset create_config_if_wanted__handled
      unset create_config_if_wanted__dir
      return 1
    fi
  fi

  unset create_config_if_wanted__handled
  unset create_config_if_wanted__dir
  return 0
}

##
# Process the removal of a config file
#
# $1 is handled by remove
# $1 config directory
remove_config_if_wanted()
{
  remove_config_if_wanted__handled="$1"
  remove_config_if_wanted__dir="$2"

  if [ "${remove_config_if_wanted__handled}" -ne 0 ]; then
    if [ ! -z "${__remove_config_name}" ]; then
      check_config_dir_conditions "${remove_config_if_wanted__dir}" \
        || return 1
      check_binary rm || return 1
      remove_config_if_wanted__file="$(cat << EOF
${remove_config_if_wanted__dir}/${__remove_config_name}.${CONFIG_VERSION}
EOF
)"

      rm -f "${remove_config_if_wanted__file}"
      printf -- "Remove config: %s\n" "${remove_config_if_wanted__file}"

      unset remove_config_if_wanted__file
    else
      printf -- "ERROR: No config specified.\n"

      unset remove_config_if_wanted__dir
      unset remove_config_if_wanted__handled
      return 1
    fi
  fi

  unset remove_config_if_wanted__dir
  unset remove_config_if_wanted__handled
  return 0
}

##
# List all existing git-ssh configurations
#
# $1 configuration directory
list_configs()
{
  list_configs__config_dir="$1"
  check_config_dir_conditions "${list_configs__config_dir}" || return 1
  check_binary ls || return 1
  check_binary wc || return 1
  check_binary head || return 1

  printf -- "Config directory: %s\n" "${list_configs__config_dir}"

  list_configs__count=0
  for list_configs__file in "${list_configs__config_dir}"/*; do
    log "Potential config at: %s" "${list_configs__file}"
    if [ -f "${list_configs__file}" ]; then
      list_configs__count=$((list_configs__count + 1))
      printf -- "[%s]\n" "$(basename "${list_configs__file}")"
      printf -- "Path: %s\n" "$(cat "${list_configs__file}" )"
      echo
    fi
  done

  echo
  printf -- "Number of configs: %d\n" "${list_configs__count}"

  unset list_configs__config_dir
  unset list_configs__count
  return 0
}

##
# Check that the configuration directory exists
#
# $1 configuration directory
check_config_dir_conditions()
{
  check_config_dir_conditions__dir="$1"

  # No config dir specified
  log "Check for set config dir..."
  if [ -z "${check_config_dir_conditions__dir}" ]; then
    printf -- "ERROR: No config_dir specified\n"

    unset check_config_dir_conditions__dir
    return 1
  fi

  # Check for the existance of the config file
  log "Check that config dir exists as a directory..."
  if [ ! -d "${check_config_dir_conditions__dir}" ]; then
    check_binary mkdir || return 1

    # If the directory does not exist, make it
    printf -- "Creating config directory at: %s\n" \
      "${check_config_dir_conditions__dir}"
    mkdir -p "${check_config_dir_conditions__dir}" || {
      printf -- "%s\n" "$(cat << EOF
ERROR: config_dir could not be created at:  ${check_config_dir_conditions__dir}
EOF
)"
      unset check_config_dir_conditions__dir
      return 1
    }
  fi

  unset check_config_dir_conditions__dir
  return 0
}

##
# Check that the ssh_key is defined
#
# $1 ssh_key variable
check_ssh_key_conditions()
{
  check_ssh_key_conditions__ssh="$1"

  log "Check that an ssh_key was requested..."
  if [ -z "${check_ssh_key_conditions__ssh}" ]; then
    # No ssh key was requested
    printf -- "ERROR: No ssh_key was requested\n"
    return 1
  fi

  unset check_ssh_key_conditions__ssh
  return 0
}

##
# Check that the wrapper can continue
#
# $1 configuration directory
# $2 ssh_key variable
check_wrapper_conditions()
{
  check_wrapper_conditions__config="$1"
  check_wrapper_conditions__ssh="$2"

  log "Check that wrapper can continue..."
  check_config_dir_conditions "${check_wrapper_conditions__config}"|| return 1
  check_ssh_key_conditions "${check_wrapper_conditions__ssh}" || return 1

  unset check_wrapper_conditions__config
  return 0
}

##
# Auto update an old config file from version 1 to 2
#
# $1 config file directory
# $2 config file name
autoupdate_old_config()
{
  autoupdate_old_config__dir="$1"
  autoupdate_old_config__config="$2"
  autoupdate_old_config__base_config="$(cat << EOF
$(basename "${autoupdate_old_config__config}")
EOF
)"

  # Upgrading from git-ssh config version 1
  log "Old config file found at: %s" "${autoupdate_old_config__base_config}"
  log "Auto upgrade to new format"
  check_binary head || return 1

  # Get the old ssh_path from the original config file
  autoupdate_old_config__old="$(head -n 1 \
    < "${autoupdate_old_config__config}" )"
  autoupdate_old_config__mashup="$(cat << EOF
${autoupdate_old_config__base_config}:${autoupdate_old_config__old}
EOF
)"
  log "Run artificial call: handle_create_config %s" \
    "${autoupdate_old_config__mashup}"
  handle_create_config "${autoupdate_old_config__mashup}" || return 1

  # Pass a artificial handled flag
  create_config_if_wanted 1 "${autoupdate_old_config__dir}" || {
    log "Failed to auto generate config for version: %s" "${CONFIG_VERSION}"

    unset autoupdate_old_config__config
    unset autoupdate_old_config__dir
    unset autoupdate_old_config__base_config
    unset autoupdate_old_config__old
    unset autoupdate_old_config__mashup
    return 1
  }

  log "Auto generate config for version: %s" "${CONFIG_VERSION}"
  log "Remove old config %s" "${autoupdate_old_config__config}"
  check_binary rm || return 1
  rm -f "${autoupdate_old_config__config}"

  # Set the __git_ssh_path
  __git_ssh_path="${autoupdate_old_config__config}.${CONFIG_VERSION}"
  log "Set __git_ssh_path to: %s" "${__git_ssh_path}"

  unset autoupdate_old_config__config
  unset autoupdate_old_config__dir
  unset autoupdate_old_config__base_config
  unset autoupdate_old_config__old
  unset autoupdate_old_config__mashup
  return 0
}

##
# Locate all the configurations in the config_dir
#
# $1 configuration directory
# $2 ssh key
locate_config_file()
{
  locate_config_file__dir="$1"
  locate_config_file__ssh="$2"

  # Path expanstion via shell
  log "Find configs in %s" "${locate_config_file__dir}"
  for locate_config_file__config in "${locate_config_file__dir}"/*; do

    # Make sure we've found a config file, not folder
    log "Check that %s is a file, not folder" "${locate_config_file__config}"
    if [ ! -d "${locate_config_file__config}" ]; then
      # Read the config if it is the one we want
      locate_config_file__base_config="$(cat << EOF
$(basename "${locate_config_file__config}")
EOF
)"
      log "Check for match at (config): %s and (key): %s" \
        "${locate_config_file__base_config}" "${locate_config_file__ssh}.${CONFIG_VERSION}"
      if [ "${locate_config_file__base_config}" \
        = "${locate_config_file__ssh}" ]; then
        autoupdate_old_config "${locate_config_file__dir}" \
          "${locate_config_file__config}" || return 1
      elif [ "${locate_config_file__base_config}" \
        = "${locate_config_file__ssh}.${CONFIG_VERSION}" ]; then
        __git_ssh_path="${locate_config_file__config}"
        log "Set __git_ssh_path to: %s" "${__git_ssh_path}"
        break
      fi
      unset locate_config_file__base_config
    fi

    unset locate_config_file__config
  done

  unset locate_config_file__dir
  unset locate_config_file__ssh
  return 0
}

##
# Check that the ssh_path exists
#
# $1 ssh_key name
check_valid_ssh_path()
{
  check_valid_ssh_path__name="$1"

  # If no matching key was found
  log "Check for __git_ssh_path: %s" "${__git_ssh_path}"
  if [ -z "${__git_ssh_path}" ]; then
    printf -- "%s\n" "$(cat << EOF
ERROR: No key found which matches the requested \
key: ${check_valid_ssh_path__name}
EOF
)"
    return 1
  fi

  unset check_valid_ssh_path__name
  return 0
}

##
# Print current version
#
print_version()
{
  printf -- "git-ssh [%s]\n" "${VERSION}"
  echo

  return 0
}

##
# Print wrapper centric help
#
list_wrapper_help()
{
  print_version
  printf -- "%s\n" "$(cat << EOF
options

  --ssh CONFIG               The name identifier of a config file in the \
\${config_dir}
  --ssh-args COMMA-OPTIONS   Comma separated list of options to pass to ssh
  --config-dir DIR           The path to the directory where configs are stored
  --create-config NAME:PATH  Create a config called NAME with
                             the path PATH. Does not stop operation \
following completion
  --remove-config NAME       Remove the config specified by NAME
                             Does not stop operation following completion
  --list-configs             Lists the contents of the \${config_dir}
                             Stops operation following completion
  --wrapper-debug            Enables debugging statements
  --wrapper-version          Prints the current wrapper version
  --wrapper-help             Prints only this help block
EOF
)"

  return 0
}

##
# Appends a plain argument to the list that is passed through to $GIT_BINARY
#
# $1 argument
append_git_argument()
{
  append_git_argument__arg="$1"

  log "Append git argument: '%s'" "${append_git_argument__arg}"
  __git_args="$(array_append "${__git_args}" "${append_git_argument__arg}")"

  unset append_git_argument__arg
  return 0
}

##
# Parse git_args into parameters and then run git
# Arguments are not passed to this function, but rather are evaluated within
# shellcheck disable=SC2120
run_git()
{
  log "Convert git args: %s to positional parameters" "${__git_args}"

  # Clear options
  log "Clear options"
  set --

  # Split the IFS by newlines
  old_ifs="${IFS}"
  IFS="
"

  for element in ${__git_args}; do
    log "Args current: %s" "$*"
    elem="$(printf -- "%s" "${element}" | array_decode)"
    if [ -n "${elem}" ]; then
      log "Add arg: %s" "${elem}"
      set -- "$@" "${elem}"
    fi
    unset elem
  done

  # Reset IFS
  IFS="${old_ifs}"

  log "Git binary: %s" "${GIT_BINARY}"
  log "Parameters: %s" "$*"
  exec "${GIT_BINARY}" "$@"
}

##
# Main function
#
# $@ command line arguments
main()
{
  # handlers
  handled_by_wrapper=0
  handled_by_create=0
  handled_by_remove=0
  should_list_configs=0

  ssh_key=""
  ssh_args=""

  # Location of the dir with configs stored
  config_dir="${XDG_CONFIG_HOME:-${HOME}/.config}/git-ssh"

  # We need git, cat, env, and ssh
  # In the case of git, we check that the path resolves
  if [ ! -x "${GIT_BINARY}" ]; then
    printf -- "Git must be installed and located at: %s\n" "${GIT_BINARY}"
    return 1
  fi

  check_binary cat || return 1
  check_binary ssh || return 1
  check_binary env || return 1

  # We have everything, let's go
  if [ -z "$1" ]; then
    # Just run git
    exec "${GIT_BINARY}" "$@"
  fi

  if [ $# -gt 0 ]; then
    long_option=
    long_option_has_arg=
    optind_expanded=
    eval optind_expanded="\$${OPTIND}"
    while [ -n "${optind_expanded}" ]; do
      log "CURRENT: %s" "$1"
      while getopts ":-:" option; do
        log "OPTION: %s %s" "${option}" "${OPTARG}"
        # Set only on long option with arg
        if [ -n "${long_option}" ]; then
          printf -- "Long option --%s expects argument\n" "${long_option}"
          return 1
        fi

        long_option=""
        case "${option}" in
          -)
            log "parse long option: -%s%s" "${option}" "${OPTARG}"
            case "${OPTARG}" in
              list-configs)
                handled_by_wrapper=1
                should_list_configs=1
                long_option_has_arg=0
                ;;
              wrapper-debug)
                long_option_has_arg=0
                __wrapper_debug=1
                log "Turn on wrapper debugging"
                ;;
              wrapper-version)
                long_option_has_arg=0
                long_option="${OPTARG}"
                ;;
              wrapper-help)
                long_option="${OPTARG}"
                long_option_has_arg=0
                ;;
              create-config)
                long_option_has_arg=1
                handled_by_create=1
                long_option="${OPTARG}"
                ;;
              remove-config)
                long_option_has_arg=1
                handled_by_remove=1
                long_option="${OPTARG}"
                ;;
              ssh|config-dir|ssh-args)
                long_option_has_arg=1
                handled_by_wrapper=1
                long_option="${OPTARG}"
                ;;
              *)
                log "Long option that is not handled by script passed."
                append_git_argument "--${OPTARG}" || return 1
                ;;
            esac
            ;;
          *)
            log "Git option, pass arg to Git."
            append_git_argument "-${OPTARG}" || return 1
            ;;
        esac
      done

      # Re-establish the current OPTIND target
      if [ $# -ge ${OPTIND} ]; then
        eval optind_expanded="\$${OPTIND}"
      else
        optind_expanded=""
      fi

      log "Continuing: %s | %s" "${long_option}" "${optind_expanded}"
      if [ -n "${long_option}" ]; then
        # Call should be processed by wrapper
        if [ "${long_option_has_arg}" -eq 1 ]; then
          if [ -z "${optind_expanded}" ]; then
            printf -- "Long option --%s expects argument\n" "${long_option}"
            return 1
          fi

          # This is a plain arg and should be handled by one of
          # the options which takes an argument
          log "Has option with argument: %s %s" "${long_option}" \
            "${optind_expanded}"
          case "${long_option}" in
            ssh)
              ssh_key="${optind_expanded}"
              ;;
            config-dir)
              config_dir="${optind_expanded}"
              ;;
            remove-config)
              handle_remove_config "${config_dir}" \
                "${optind_expanded}" || return 1
              ;;
            ssh-args)
              ssh_args="$(handle_ssh_args_option \
                "${optind_expanded}")" || return 1
              ;;
            create-config)
              handle_create_config "${optind_expanded}" || return 1
              ;;
          esac
        else
          # This is a plain arg and should be handled by one of
          # the options which takes an argument
          log "Has option no argument: %s" "${long_option}"
          case "${long_option}" in
            wrapper-help)
              list_wrapper_help || return 1
              return 0
              ;;
            # Do not override git calls
            #
            # help)
            #   list_wrapper_help || return 1
            #   eval "exec ${GIT_BINARY} ${__git_args} --help"
            #   ;;
            wrapper-version)
              print_version || return 1
              return 0
              ;;
            # Do not override git calls
            #
            # version)
            #   print_version || return 1
            #   eval "exec ${GIT_BINARY} ${__git_args} --version"
            #   ;;
            wrapper-debug)
              log "Turn on wrapper debugging"
              ;;
          esac
        fi
      else
        if [ -n "${optind_expanded}" ]; then
          # Just pass argument to git
          log "No option, pass arg to Git."
          append_git_argument "${optind_expanded}" || return 1
        else
          log "No argument passed"
        fi
      fi

      # Set back to null
      long_option=
      long_option_has_arg=0

      option_shift_count="${OPTIND}"
      log "Option count: %s" "$#"
      log "If possible, shift by: %s" "${option_shift_count}"
      while [ "$#" -lt "${option_shift_count}" ]; do
        log "Shift count is too large, decrement"
        option_shift_count=$((option_shift_count - 1))
        log "If possible, shift by: %s" "${option_shift_count}"
      done

      # Need this here incase the loop doesn't run
      if [ "$#" -ge "${option_shift_count}" ]; then
        # Shift the options
        log "Shift by: %s" "${option_shift_count}"
        shift ${option_shift_count}
        OPTIND=1
      fi

      # Unset
      unset option_shift_count
    done
  fi

  log "After loop argument count: %s" "$#"
  log "After loop OPTIND count: %s" "${OPTIND}"

  # Remove the config if requested
  remove_config_if_wanted "${handled_by_remove}" \
    "${config_dir}" || return 1

  # Create the config if requested
  create_config_if_wanted "${handled_by_create}" \
    "${config_dir}" || return 1

  if [ "${should_list_configs}" -ne 0 ]; then
    list_configs "${config_dir}" || return 1
    return 1
  fi

  # Wrapper does not play a part
  if [ "${handled_by_wrapper}" -eq 0 ]; then
    # Just run git
    log "Call does not request wrapper options, call git normally"

    # shellcheck disable=SC2119
    run_git
    return 0
  fi

  # Make sure everything is set
  check_wrapper_conditions "${config_dir}" "${ssh_key}" || return 1

  # Read the config file requested and check its valid
  locate_config_file "${config_dir}" "${ssh_key}" || return 1
  check_valid_ssh_path "${ssh_key}"|| return 1

  # Run git using the ssh key that was found
  # Git will handle any errors related to a bad path
  # to an SSH key, just as if you had entered this env var yourself

  # Escape the double quotes so that the shell does not attempt to parse the
  # options given to GIT_SSH_COMMAND
  #
  # Escape the GIT_SSH_COMMAND with double quotes to allow paths with spaces
  # and single quotes to be passed through
  log "Call requests wrapper options, call wrapper git"
  log "GIT_SSH_COMMAND='ssh -F \"%s\" %s'" "${__git_ssh_path}" "${ssh_args}"

  # shellcheck disable=SC2089
  GIT_SSH_COMMAND="ssh -F '${__git_ssh_path}' ${ssh_args}"

  # shellcheck disable=SC2090
  export GIT_SSH_COMMAND

  # shellcheck disable=SC2119
  run_git
  return 0
}

# Export the LC as the default C so that we do not run into locale based quirks
LC_ALL=C
export LC_ALL

# git-ssh
readonly VERSION="1.2.3"

# config file version
readonly CONFIG_VERSION="2"

# Location of the actual git binary
readonly GIT_BINARY="/usr/bin/git"

# List of plain arguments to pass to git
__git_args=$(array_create "")

# The ssh key git should use
__git_ssh_path=""

# No argument options
__wrapper_debug=0

# Parameters for creating a config
__create_config_name=""
__create_config_target=""

# Parameters for removing a config
__remove_config_name=""

main "$@" || exit 1
# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:
