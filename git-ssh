#!/bin/sh
#  Copyright (C) 2016 Peter Kenji Yamanaka
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# A bash script that wraps git calls to work with a specific SSH key

# git-ssh
# An ssh-key selection wrapper for git

# NOTE: This script does not check that the SSH key is valid, and does not
# sanitize input. Please make sure all input passed into the script is
# valid either in the context of the script or the git binary itself

# git-ssh
version="0.1.0"

# options
# The script currently handles the following option(s):
#
# --ssh CONFIG   The name identifier of a config file in the ${config_dir}
#                The contents expected in the CONFIG file are listed in the
#                CONFIGURATION section
#
#
# CONFIGURATION
#
# A valid config file can take any name, with or without spaces, and can
# have any extension, though normal convention is to have none. For any
# config files with spaces in the name, they will need to be properly
# escaped.
#
# Examples:     rsa    "second key"   github.ssh.key
#
# A valid config file consists of exactly one line of content: A path
# to an ssh key. While a relative path will work, it is generally recommended
# that one uses absolute paths to be clear as to which key is being requested.
# Comments are not allowed in the config file, in any kind of syntax.
# Any variables in the config file will be interpreted by the shell.
#
# Example:
# In example config file <rsa>
# ~/.ssh/id_rsa
#
# In example config file <"second key">
# ${HOME}/.ssh/id_dsa


# Check the environment path for the given binary, exit if it is not found
check_for_binary()
{
  if ! which "$1" > /dev/null 2>&1; then
    printf -- "The '%s' binary is required for this script.\n" "$1"
    printf -- "Please install '%s' onto your system.\n" "$1"

    # Error code 1: Missing binary
    exit 1
  fi
}

# Location of the actual git binary
_git="/usr/bin/git"

# Location of the dir with configs stored
config_dir="$XDG_CONFIG_HOME/git-ssh"

# The ssh key requested
ssh_key=""

# Options to passthrough to git
# KLUDGE not currently implemented
#        See below in the switch statement
#
# git_options=""

# We need git, cat, env, and ssh
# In the case of git, we check that the path resolves
check_for_binary "${_git}"
check_for_binary cat
check_for_binary ssh
check_for_binary env

# We have everything, let's go
if [ -z "$1" ]; then
  # Just run git
  exec "${_git}"
fi

# Due to parsing limitations, the --ssh must be the first option specified
# If it is not, we assume it is not requested
#
# This is because git has issues with us snatching away the $@ variable, as
# for example assume that we store vars into a temporary variable
#
# ${git_options}="status help clone"
#
# Git will fail saying that there is no valid option 'status help clone'
# It will properly handle the status option when using the $@ variable however.
#
# Unless a work around is found to allow git to parse individual arguments,
# this hard requirement must stay.
case "$1" in
  "--ssh")
    # Eat the current $1
    shift

    # Check if it exists
    if [ ! -z "$1" ]; then
      # Eat the current $1
      ssh_key="$1"
      shift
    fi
    ;;
  "--config-dir")
    # Eat the current $1
    shift

    # Check if it exists
    if [ ! -z "$1" ]; then
      # Eat the current $1
      config_dir="$1"
      shift
    fi
    ;;
  *)
    # git_options="$1 ${git_options}"
    # shift

    # KLUDGE Limiations
    # Do nothing
    ;;
esac

# No ssh key was requested
if [ -z "${ssh_key}" ];then
  # the call to exec will exit

  # exec "${_git}" "${git_options}"
  exec "${_git}" "$@"
fi

# An ssh key is requested

# Check for the existance of the config file
if [ ! -d ${config_dir} ]; then
  printf -- "Please make sure the config dir exists at:  ${config_dir}\n"

  # Error code 2: No config dir
  exit 2
fi

# The ssh key git should use
git_ssh_path=""

# Go into the config dir

# Path expanstion via shell
for config in "${config_dir}"/*; do

  # Make sure we've found a config file, not folder
  if [ ! -d "${config}" ]; then
    # Read the config if it is the one we want
    if [ "$(basename ${config})" = "${ssh_key}" ]; then
      git_ssh_path=$(cat "$config")
      break
    fi
  fi
done

# If no matching key was found
if [ -z "${git_ssh_path}" ]; then
  printf -- "No SSH key found which matches the requested key: ${ssh_key}\n"

  # Error code 3: Bad key requested
  exit 3
fi

# Run git using the ssh key that was found
# Git will handle any errors related to a bad path
# to an SSH key, just as if you had entered this env var yourself

# exec env GIT_SSH_COMMAND="ssh -i ${git_ssh_path}" "${_git}" "${git_options}"
exec env GIT_SSH_COMMAND="ssh -i ${git_ssh_path}" "${_git}" "$@"

# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:
